<h1>의존 (dependency)</h1>

의존성이 있는 관계

1. 한 객체가 다른 객체를 생성


2. 다른 객체의 메서드 호출


3. 파라미터로 전달받는 경우


다른 타입에 의존을 한다는 것 - 의존하는 타입에 변경이 발생할 때 나도 함께 변경될 가능성이 높다는 것


C 클래스가 B 클래스에 의존하고 B 클래스가 A 클래스에 의존하고 A 클래스는 C 클래스에 의존할 경우,

A 클래스의 변화는 C 클래스까지 영향을 줄 수 있으며 C 클래스의 변화는 A 클래스에 영향을 줄 수 있음

결국 A 클래스를 변경한 여파가 다시 A 클래스의 또 다른 변화를 유발할 수 있음

=> 순환 의존이 발생하지 않도록 해야 함


<h1>역할과 책임</h1>
객체에서 가장 많이 나오는 이야기 - '역할' / '책임'

객체 지향의 본질: '협력하는 객체들의 공동체'를 창조하는 것

객체 지향 설계의 핵심 - 협력을 구성하기 위해 적절한 객체를 찾고 적절한 책임을 할당하는 과정

즉, 객체 지향 패러다임 관점에서 핵심은 역할, 책임, 협력


협력: 객체들이 기능 구현을 위해 수행하는 상호 작용

	- '메세지 전송'(오퍼레이션 실행을 요청하는 것)은 객체 사이의 협력을 위해 사용하는 유일한 커뮤니케이션 수단
	
	- 메세지를 수신한 객체는 어떻게 처리할 지 '스스로 결정'
	
책임: 객체가 협력에 참여하기 위해 수행하는 로직

역할: 객체들이 어떤 특정한 협력 안에서 수행하는 책임의 집합


* 실질적으로 객체에 대한 '역할'이나 '책임'이 필요한건 '의존성을 어떻게 관리하느냐'임


<h1>설계</h1>
설계: 어떤 클래스에 어떤 코드를 넣어야 하는 지, 코드를 어떻게 배치할 것인가에 대한 의사 결정

어떻게 설계해야 하는가? - 같이 변경되는 코드는 같이 놔야 하고 같이 변경되면 안되는 코드는 따로 놔야 함


설계의 핵심은 의존성 - '변경'에 초점을 맞춰 의존성에 따라 배치하는 것


<h1>의존성 종류</h1>
의존성은 크게 2가지로 나눌 수 있음 - <b>클래스</b> 사이의 의존성/<b>패키지</b> 사이의 의존성

<h3>- 클래스(class) 사이의 의존성</h3>
<h5>1. 연관 관계 (Association)</h5>
    : A에서 B로 이동 가능

<br/>
<pre>
<code>
Class A {
  private B b;
 }
</code>
</pre>

<h5>2. 의존 관계 (Dependency)</h5>
  : 파라미터나 리턴 타입에 그 타입이 나오거나 메소드에서 그 타입의 인스턴스를 생성하는 경우
  
 <br/>
 <pre>
<code>
Class A{
  public method(B b){
    return new B();
  }
}
</code>
</pre>


* 연관 관계/의존 관계 차이 
- 연관 관계 - A에서 B로 갈 수 있는 영구적인 경로 존재하는 경우

- 의존 관계 - 일시적으로 협력 관계를 경우

<h5>3. 상속 관계 (Inharitance)</h5>
  : B 클래스의 구현을 A 클래스가 상속 받는 관계 
  
<br/>
<pre>
<code>
Class A extends B { }
</code>
</pre>

<h5>4. 실체화 관계 (Realization)</h5>
  : 인터페이스를 구현하는 관계

<br/>
<pre>
<code>
Class A implements B {}
</code> 
</pre>


* 상속 관계/실체화 관계 차이
- 상속 관계 - 구현이 바뀌면 영향을 받을 가능성 존재
- 실체화 관계 - 인터페에스의 오퍼레이션 시그니처가 변경되었을 경우에만 영향 받을 가능성 존재


<h3>- 패키지 (package) 사이의 의존성</h3>
  : A 패키지가 B 패키지를 의존했을 경우 A 패키지 내의 클래스가 변경되자 B 패키지 내의 클래스가 변경된 경우
  패키지 사이의 의존성을 파악할 때 간단하게 확인할 수 있는 방법)
   - import문으로 패키지 참조/using문으로 namespace 참조


<h1>좋은 의존성을 관리하기 위한 규칙</h1>
<h3>1. 양방향 의존성 피하기</h3>

<br/>
<pre>
<code>
class A {
	private B b;

	public void setB(B b){
		this.b = b;
		this.b.setA(this);
	}
}

class B {
	private A a;
	
	public void setA(A a){
		this.a = a;	
	}	
}
</code>
</pre>

-> 하나의 클래스를 억지로 분리해둔 형태

A 클래스에서 setter를 call할 경우 B 클래스의 set 메서드를 call하고 있어 A와 B 사이의 관계를 항상 동기화 필요

-> 이런 경우는 단방향 의존성으로 바꾸기


<h3>2. 다중성이 적은 방향으로 선택하기</h3>
<br/>
<pre>
<code>
class A {
	private Collection<B> bs; // 1대다 (One-To-Many)
}

class B {
}

class A {	
}

class B {
	private A a; //다대1 (Many-To-One)
}
</code>
</pre>
	
-> B타입의 컬렉션을 인스턴스로 잡는다기 보다는 반대 방향을 인스턴스로 가지기
	
A가 B의 리스트를 갖는 것보다 B가 A의 단방향 참조를 갖는 형태가 좋음

<h3>3. 의존성이 없다면 제거하기</h3>

<h3>4. 패키지 사이의 양방향 의존성 제거하기</h3>
패키지 사이의 양방향 의존성은 '사이클'이라 표현
	
이런 경우 하나의 패키지로 볼 수 있음
